// Generated by gencpp from file adma_connect/Adma_delta.msg
// DO NOT EDIT!


#ifndef ADMA_CONNECT_MESSAGE_ADMA_DELTA_H
#define ADMA_CONNECT_MESSAGE_ADMA_DELTA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace adma_connect
{
template <class ContainerAllocator>
struct Adma_delta_
{
  typedef Adma_delta_<ContainerAllocator> Type;

  Adma_delta_()
    : Delta_Target_Longitude(0.0)
    , Delta_Target_Latitude(0.0)
    , Code_version(0)
    , Long_Delta_Distance(0.0)
    , Long_Delta_Velocity(0.0)
    , Lat_Delta_Distance(0.0)
    , Lat_Delta_Velocity(0.0)
    , Resultant_Distance(0.0)
    , Resultant_Velocity(0.0)
    , Angle_of_Orientation(0.0)
    , Delta_Time(0)
    , Target_Forward_Velocity(0.0)
    , Hunter_Forward_Velocity(0.0)
    , Target_Forward_Acceleration(0.0)
    , Hunter_Forward_Acceleration(0.0)
    , Target_Lateral_Velocity(0.0)
    , Hunter_Lateral_Velocity(0.0)
    , Target_Lateral_Acceleration(0.0)
    , Hunter_Lateral_Acceleration(0.0)
    , Target_Pitch_Angle(0.0)
    , Hunter_Pitch_Angle(0.0)
    , Target_GPS_Mode(0)
    , Hunter_GPS_Mode(0)
    , Timesec(0)
    , TimeNsec(0)  {
    }
  Adma_delta_(const ContainerAllocator& _alloc)
    : Delta_Target_Longitude(0.0)
    , Delta_Target_Latitude(0.0)
    , Code_version(0)
    , Long_Delta_Distance(0.0)
    , Long_Delta_Velocity(0.0)
    , Lat_Delta_Distance(0.0)
    , Lat_Delta_Velocity(0.0)
    , Resultant_Distance(0.0)
    , Resultant_Velocity(0.0)
    , Angle_of_Orientation(0.0)
    , Delta_Time(0)
    , Target_Forward_Velocity(0.0)
    , Hunter_Forward_Velocity(0.0)
    , Target_Forward_Acceleration(0.0)
    , Hunter_Forward_Acceleration(0.0)
    , Target_Lateral_Velocity(0.0)
    , Hunter_Lateral_Velocity(0.0)
    , Target_Lateral_Acceleration(0.0)
    , Hunter_Lateral_Acceleration(0.0)
    , Target_Pitch_Angle(0.0)
    , Hunter_Pitch_Angle(0.0)
    , Target_GPS_Mode(0)
    , Hunter_GPS_Mode(0)
    , Timesec(0)
    , TimeNsec(0)  {
  (void)_alloc;
    }



   typedef float _Delta_Target_Longitude_type;
  _Delta_Target_Longitude_type Delta_Target_Longitude;

   typedef float _Delta_Target_Latitude_type;
  _Delta_Target_Latitude_type Delta_Target_Latitude;

   typedef int32_t _Code_version_type;
  _Code_version_type Code_version;

   typedef float _Long_Delta_Distance_type;
  _Long_Delta_Distance_type Long_Delta_Distance;

   typedef float _Long_Delta_Velocity_type;
  _Long_Delta_Velocity_type Long_Delta_Velocity;

   typedef float _Lat_Delta_Distance_type;
  _Lat_Delta_Distance_type Lat_Delta_Distance;

   typedef float _Lat_Delta_Velocity_type;
  _Lat_Delta_Velocity_type Lat_Delta_Velocity;

   typedef float _Resultant_Distance_type;
  _Resultant_Distance_type Resultant_Distance;

   typedef float _Resultant_Velocity_type;
  _Resultant_Velocity_type Resultant_Velocity;

   typedef float _Angle_of_Orientation_type;
  _Angle_of_Orientation_type Angle_of_Orientation;

   typedef int32_t _Delta_Time_type;
  _Delta_Time_type Delta_Time;

   typedef float _Target_Forward_Velocity_type;
  _Target_Forward_Velocity_type Target_Forward_Velocity;

   typedef float _Hunter_Forward_Velocity_type;
  _Hunter_Forward_Velocity_type Hunter_Forward_Velocity;

   typedef float _Target_Forward_Acceleration_type;
  _Target_Forward_Acceleration_type Target_Forward_Acceleration;

   typedef float _Hunter_Forward_Acceleration_type;
  _Hunter_Forward_Acceleration_type Hunter_Forward_Acceleration;

   typedef float _Target_Lateral_Velocity_type;
  _Target_Lateral_Velocity_type Target_Lateral_Velocity;

   typedef float _Hunter_Lateral_Velocity_type;
  _Hunter_Lateral_Velocity_type Hunter_Lateral_Velocity;

   typedef float _Target_Lateral_Acceleration_type;
  _Target_Lateral_Acceleration_type Target_Lateral_Acceleration;

   typedef float _Hunter_Lateral_Acceleration_type;
  _Hunter_Lateral_Acceleration_type Hunter_Lateral_Acceleration;

   typedef float _Target_Pitch_Angle_type;
  _Target_Pitch_Angle_type Target_Pitch_Angle;

   typedef float _Hunter_Pitch_Angle_type;
  _Hunter_Pitch_Angle_type Hunter_Pitch_Angle;

   typedef int16_t _Target_GPS_Mode_type;
  _Target_GPS_Mode_type Target_GPS_Mode;

   typedef int16_t _Hunter_GPS_Mode_type;
  _Hunter_GPS_Mode_type Hunter_GPS_Mode;

   typedef int32_t _Timesec_type;
  _Timesec_type Timesec;

   typedef int32_t _TimeNsec_type;
  _TimeNsec_type TimeNsec;





  typedef boost::shared_ptr< ::adma_connect::Adma_delta_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::adma_connect::Adma_delta_<ContainerAllocator> const> ConstPtr;

}; // struct Adma_delta_

typedef ::adma_connect::Adma_delta_<std::allocator<void> > Adma_delta;

typedef boost::shared_ptr< ::adma_connect::Adma_delta > Adma_deltaPtr;
typedef boost::shared_ptr< ::adma_connect::Adma_delta const> Adma_deltaConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::adma_connect::Adma_delta_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::adma_connect::Adma_delta_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::adma_connect::Adma_delta_<ContainerAllocator1> & lhs, const ::adma_connect::Adma_delta_<ContainerAllocator2> & rhs)
{
  return lhs.Delta_Target_Longitude == rhs.Delta_Target_Longitude &&
    lhs.Delta_Target_Latitude == rhs.Delta_Target_Latitude &&
    lhs.Code_version == rhs.Code_version &&
    lhs.Long_Delta_Distance == rhs.Long_Delta_Distance &&
    lhs.Long_Delta_Velocity == rhs.Long_Delta_Velocity &&
    lhs.Lat_Delta_Distance == rhs.Lat_Delta_Distance &&
    lhs.Lat_Delta_Velocity == rhs.Lat_Delta_Velocity &&
    lhs.Resultant_Distance == rhs.Resultant_Distance &&
    lhs.Resultant_Velocity == rhs.Resultant_Velocity &&
    lhs.Angle_of_Orientation == rhs.Angle_of_Orientation &&
    lhs.Delta_Time == rhs.Delta_Time &&
    lhs.Target_Forward_Velocity == rhs.Target_Forward_Velocity &&
    lhs.Hunter_Forward_Velocity == rhs.Hunter_Forward_Velocity &&
    lhs.Target_Forward_Acceleration == rhs.Target_Forward_Acceleration &&
    lhs.Hunter_Forward_Acceleration == rhs.Hunter_Forward_Acceleration &&
    lhs.Target_Lateral_Velocity == rhs.Target_Lateral_Velocity &&
    lhs.Hunter_Lateral_Velocity == rhs.Hunter_Lateral_Velocity &&
    lhs.Target_Lateral_Acceleration == rhs.Target_Lateral_Acceleration &&
    lhs.Hunter_Lateral_Acceleration == rhs.Hunter_Lateral_Acceleration &&
    lhs.Target_Pitch_Angle == rhs.Target_Pitch_Angle &&
    lhs.Hunter_Pitch_Angle == rhs.Hunter_Pitch_Angle &&
    lhs.Target_GPS_Mode == rhs.Target_GPS_Mode &&
    lhs.Hunter_GPS_Mode == rhs.Hunter_GPS_Mode &&
    lhs.Timesec == rhs.Timesec &&
    lhs.TimeNsec == rhs.TimeNsec;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::adma_connect::Adma_delta_<ContainerAllocator1> & lhs, const ::adma_connect::Adma_delta_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace adma_connect

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::adma_connect::Adma_delta_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::adma_connect::Adma_delta_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::adma_connect::Adma_delta_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::adma_connect::Adma_delta_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::adma_connect::Adma_delta_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::adma_connect::Adma_delta_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::adma_connect::Adma_delta_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fcf8176799195097caa3033a7b951042";
  }

  static const char* value(const ::adma_connect::Adma_delta_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfcf8176799195097ULL;
  static const uint64_t static_value2 = 0xcaa3033a7b951042ULL;
};

template<class ContainerAllocator>
struct DataType< ::adma_connect::Adma_delta_<ContainerAllocator> >
{
  static const char* value()
  {
    return "adma_connect/Adma_delta";
  }

  static const char* value(const ::adma_connect::Adma_delta_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::adma_connect::Adma_delta_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#Delta_Target_Longitude and Delta_Target_Latitude\n"
"float32 Delta_Target_Longitude\n"
"float32 Delta_Target_Latitude\n"
"\n"
"#Delta_Version\n"
"int32 Code_version\n"
"\n"
"#Delta_Longitudinal\n"
"float32 Long_Delta_Distance\n"
"float32 Long_Delta_Velocity\n"
"\n"
"#Delta_Lateral\n"
"float32 Lat_Delta_Distance\n"
"float32 Lat_Delta_Velocity\n"
"\n"
"#Delta_Resultant\n"
"float32 Resultant_Distance\n"
"float32 Resultant_Velocity\n"
"\n"
"#Delta_Angle\n"
"float32 Angle_of_Orientation\n"
"\n"
"#Delta_Time_ForwardVel\n"
"int32 Delta_Time\n"
"float32 Target_Forward_Velocity\n"
"float32 Hunter_Forward_Velocity\n"
"\n"
"#Delta_ForwardAccel_LatVel\n"
"float32 Target_Forward_Acceleration\n"
"float32 Hunter_Forward_Acceleration\n"
"float32 Target_Lateral_Velocity\n"
"float32 Hunter_Lateral_Velocity\n"
"\n"
"#Delta_LatAccel_PitchAngle\n"
"float32 Target_Lateral_Acceleration\n"
"float32 Hunter_Lateral_Acceleration\n"
"float32 Target_Pitch_Angle\n"
"float32 Hunter_Pitch_Angle\n"
"\n"
"#Delta_GPS_Mode\n"
"int16 Target_GPS_Mode\n"
"int16 Hunter_GPS_Mode\n"
"\n"
"# MobileEye Time Comparison\n"
"int32 Timesec\n"
"int32 TimeNsec\n"
;
  }

  static const char* value(const ::adma_connect::Adma_delta_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::adma_connect::Adma_delta_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.Delta_Target_Longitude);
      stream.next(m.Delta_Target_Latitude);
      stream.next(m.Code_version);
      stream.next(m.Long_Delta_Distance);
      stream.next(m.Long_Delta_Velocity);
      stream.next(m.Lat_Delta_Distance);
      stream.next(m.Lat_Delta_Velocity);
      stream.next(m.Resultant_Distance);
      stream.next(m.Resultant_Velocity);
      stream.next(m.Angle_of_Orientation);
      stream.next(m.Delta_Time);
      stream.next(m.Target_Forward_Velocity);
      stream.next(m.Hunter_Forward_Velocity);
      stream.next(m.Target_Forward_Acceleration);
      stream.next(m.Hunter_Forward_Acceleration);
      stream.next(m.Target_Lateral_Velocity);
      stream.next(m.Hunter_Lateral_Velocity);
      stream.next(m.Target_Lateral_Acceleration);
      stream.next(m.Hunter_Lateral_Acceleration);
      stream.next(m.Target_Pitch_Angle);
      stream.next(m.Hunter_Pitch_Angle);
      stream.next(m.Target_GPS_Mode);
      stream.next(m.Hunter_GPS_Mode);
      stream.next(m.Timesec);
      stream.next(m.TimeNsec);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Adma_delta_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::adma_connect::Adma_delta_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::adma_connect::Adma_delta_<ContainerAllocator>& v)
  {
    s << indent << "Delta_Target_Longitude: ";
    Printer<float>::stream(s, indent + "  ", v.Delta_Target_Longitude);
    s << indent << "Delta_Target_Latitude: ";
    Printer<float>::stream(s, indent + "  ", v.Delta_Target_Latitude);
    s << indent << "Code_version: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Code_version);
    s << indent << "Long_Delta_Distance: ";
    Printer<float>::stream(s, indent + "  ", v.Long_Delta_Distance);
    s << indent << "Long_Delta_Velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Long_Delta_Velocity);
    s << indent << "Lat_Delta_Distance: ";
    Printer<float>::stream(s, indent + "  ", v.Lat_Delta_Distance);
    s << indent << "Lat_Delta_Velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Lat_Delta_Velocity);
    s << indent << "Resultant_Distance: ";
    Printer<float>::stream(s, indent + "  ", v.Resultant_Distance);
    s << indent << "Resultant_Velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Resultant_Velocity);
    s << indent << "Angle_of_Orientation: ";
    Printer<float>::stream(s, indent + "  ", v.Angle_of_Orientation);
    s << indent << "Delta_Time: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Delta_Time);
    s << indent << "Target_Forward_Velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Target_Forward_Velocity);
    s << indent << "Hunter_Forward_Velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Hunter_Forward_Velocity);
    s << indent << "Target_Forward_Acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.Target_Forward_Acceleration);
    s << indent << "Hunter_Forward_Acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.Hunter_Forward_Acceleration);
    s << indent << "Target_Lateral_Velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Target_Lateral_Velocity);
    s << indent << "Hunter_Lateral_Velocity: ";
    Printer<float>::stream(s, indent + "  ", v.Hunter_Lateral_Velocity);
    s << indent << "Target_Lateral_Acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.Target_Lateral_Acceleration);
    s << indent << "Hunter_Lateral_Acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.Hunter_Lateral_Acceleration);
    s << indent << "Target_Pitch_Angle: ";
    Printer<float>::stream(s, indent + "  ", v.Target_Pitch_Angle);
    s << indent << "Hunter_Pitch_Angle: ";
    Printer<float>::stream(s, indent + "  ", v.Hunter_Pitch_Angle);
    s << indent << "Target_GPS_Mode: ";
    Printer<int16_t>::stream(s, indent + "  ", v.Target_GPS_Mode);
    s << indent << "Hunter_GPS_Mode: ";
    Printer<int16_t>::stream(s, indent + "  ", v.Hunter_GPS_Mode);
    s << indent << "Timesec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Timesec);
    s << indent << "TimeNsec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.TimeNsec);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ADMA_CONNECT_MESSAGE_ADMA_DELTA_H
